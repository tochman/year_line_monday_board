import React, {
  useState,
  useEffect,
  useCallback,
} from "react";
import "./App.css";
import mondaySdk from "monday-sdk-js";
import "@vibe/core/tokens";
import { Flex, Text, Box } from "@vibe/core";

import GanttView from "./components/GanttView";
import WheelLoader from "./components/WheelLoader";
import useMondayBoard from "./hooks/useMondayBoard";

const monday = mondaySdk();

// Set API token for development mode
const isDevelopment =
  !window.location.ancestorOrigins?.length &&
  (window.location.hostname === "localhost" ||
    window.location.hostname === "127.0.0.1");

if (isDevelopment && import.meta.env.VITE_MONDAY_API_TOKEN) {
  monday.setToken(import.meta.env.VITE_MONDAY_API_TOKEN);
}

const App = () => {
  const {
    loading,
    error,
    wheelItems,
    groups,
    updateItemDates,
  } = useMondayBoard();

  // Notify Monday that user has value
  useEffect(() => {
    monday.execute("valueCreatedForUser");
  }, []);

  // Handle item update from Gantt (if drag/resize is enabled in future)
  const handleItemUpdate = useCallback(
    async (updatedItem) => {
      if (updatedItem && updatedItem.id) {
        const startDate = updatedItem.startDate;
        const endDate = updatedItem.endDate;

        // Validate dates
        if (endDate && startDate && endDate < startDate) {
          console.warn("End date before start date, skipping update");
          return;
        }

        // Save to Monday.com
        await updateItemDates(updatedItem.id, startDate, endDate);
      }
    },
    [updateItemDates]
  );

  // Show loading state
  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <WheelLoader />
      </div>
    );
  }

  // Show error state
  if (error) {
    return (
      <Box padding="large">
        <Text type="text1" color="negative">
          Error loading board data: {error}
        </Text>
      </Box>
    );
  }

  return (
    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      <GanttView
        items={wheelItems}
        groups={groups}
        onUpdateItem={handleItemUpdate}
      />
    </div>
  );
};

export default App;

  if (!items || items.length === 0 || !position) return null;

  return (
    <Box
      style={{
        position: "fixed",
        left: position.x + 10,
        top: position.y + 10,
        zIndex: 10000,
        pointerEvents: "auto",
      }}
      onClick={(e) => e.stopPropagation()}
      backgroundColor="primary"
      border
      rounded="medium"
      shadow="medium"
      padding="medium"
      className="cluster-tooltip"
    >
      <Flex justify="space-between" align="center" style={{ marginBottom: '8px' }}>
        <Text type="text2" weight="bold">{items.length} items at this location</Text>
        <IconButton
          icon={Close}
          size="xs"
          kind="tertiary"
          ariaLabel="Close"
          onClick={onClose}
        />
      </Flex>

      <Text type="text3" color="secondary" style={{ marginBottom: '12px', display: 'block' }}>
        Filter by month or quarter to get a better view of these items.
      </Text>

      <Button
        kind="primary"
        size="small"
        onClick={onFilter}
        style={{ width: '100%' }}
      >
        Filter
      </Button>
    </Box>
  );
};

// Custom tooltip component
const ItemTooltip = ({
  item,
  position,
  onClose,
  onNameUpdate,
  groups,
  users,
  onUpdate,
}) => {
  const [editedName, setEditedName] = useState(item?.name || "");
  const [editedStartDate, setEditedStartDate] = useState(item?.startDate || "");
  const [editedEndDate, setEditedEndDate] = useState(item?.endDate || "");
  const [editedGroupId, setEditedGroupId] = useState(() => {
    // Extract group ID from ringId (format: "ring-{groupId}")
    return item?.ringId?.replace("ring-", "") || "";
  });
  const [editedUserIds, setEditedUserIds] = useState(item?.assignedUserIds || []);
  const [hasChanges, setHasChanges] = useState(false);

  // Track if any field changed
  useEffect(() => {
    const nameChanged = editedName !== item.name;
    const startDateChanged = editedStartDate !== item.startDate;
    const endDateChanged = editedEndDate !== (item.endDate || "");
    const groupIdChanged = editedGroupId !== item.ringId?.replace("ring-", "");
    const usersChanged = JSON.stringify(editedUserIds.sort()) !== JSON.stringify((item.assignedUserIds || []).sort());
    setHasChanges(
      nameChanged || startDateChanged || endDateChanged || groupIdChanged || usersChanged
    );
  }, [editedName, editedStartDate, editedEndDate, editedGroupId, editedUserIds, item]);

  // Validate dates
  const hasDateError =
    editedEndDate && editedStartDate && editedEndDate < editedStartDate;
  const canSave = hasChanges && !hasDateError;

  if (!item || !position) return null;

  const handleSave = async () => {
    // Call update callback with all changes
    await onUpdate?.({
      id: item.id,
      name: editedName,
      startDate: editedStartDate,
      endDate: editedEndDate || null,
      ringId: `ring-${editedGroupId}`,
      activityId: `activity-${editedGroupId}`,
      userIds: editedUserIds,
    });

    onClose();
  };

  const handleCancel = () => {
    setEditedName(item.name);
    setEditedStartDate(item.startDate);
    setEditedEndDate(item.endDate || "");
    setEditedGroupId(item.ringId?.replace("ring-", "") || "");
    onClose();
  };

  return (
    <Box
      style={{
        position: "fixed",
        left: position.x + 10,
        top: position.y + 10,
        zIndex: 10000,
        pointerEvents: "auto",
      }}
      onClick={(e) => e.stopPropagation()}
      border
      rounded="medium"
      shadow="medium"
      padding="medium"
      className="item-tooltip-dialog"
    >
      {/* Header */}
      <Flex justify="space-between" align="center" style={{ marginBottom: '12px' }}>
        <Text type="text1" weight="bold">Edit Item</Text>
        <IconButton
          icon={Close}
          size="xs"
          kind="tertiary"
          ariaLabel="Close"
          onClick={handleCancel}
        />
      </Flex>

      {/* Name field */}
      <div style={{ marginBottom: "12px" }}>
        <TextField
          title="Name"
          value={editedName}
          onChange={(value) => setEditedName(value)}
          placeholder="Item name"
          size="medium"
        />
      </div>

      {/* Group selector */}
      <div style={{ marginBottom: "12px" }}>
        <Text type="text3" weight="medium" color="secondary" style={{ marginBottom: '4px', display: 'block' }}>Group</Text>
        <Dropdown
          placeholder="Select group"
          options={groups?.map((group) => ({
            value: group.id,
            label: group.title,
          })) || []}
          value={editedGroupId ? { value: editedGroupId, label: groups?.find(g => g.id === editedGroupId)?.title } : null}
          onChange={(option) => setEditedGroupId(option?.value || "")}
          size="medium"
          clearable={false}
        />
      </div>

      {/* User assignment */}
      <div style={{ marginBottom: "12px" }}>
        <Text type="text3" weight="medium" color="secondary" style={{ marginBottom: '4px', display: 'block' }}>Assigned To</Text>
        {users && users.length > 0 ? (
          <Dropdown
            placeholder="Select team members..."
            multi
            multiline
            clearable
            searchable
            options={users.map(user => ({
              value: parseInt(user.id),
              label: user.name
            }))}
            value={editedUserIds.map(id => {
              const user = users.find(u => parseInt(u.id) === id);
              return user ? { value: id, label: user.name } : null;
            }).filter(Boolean)}
            onChange={(selectedOptions) => {
              const newIds = selectedOptions 
                ? selectedOptions.map(opt => opt.value) 
                : [];
              setEditedUserIds(newIds);
            }}
            size="medium"
          />
        ) : (
          <Text type="text2" color="secondary" style={{ fontStyle: 'italic', padding: '8px' }}>
            No team members available
          </Text>
        )}
      </div>

      {/* Start date */}
      <div style={{ marginBottom: "12px" }}>
        <TextField
          title="Start Date"
          type="date"
          value={editedStartDate}
          onChange={(value) => setEditedStartDate(value)}
          size="medium"
          iconName={Calendar}
        />
      </div>

      {/* End date */}
      <div style={{ marginBottom: "16px" }}>
        <TextField
          title="End Date (optional)"
          type="date"
          value={editedEndDate}
          onChange={(value) => setEditedEndDate(value)}
          size="medium"
          iconName={Calendar}
          validation={hasDateError ? { status: "error", text: "End date cannot be before start date" } : null}
        />
      </div>

      {/* Action buttons */}
      <Flex gap="small" justify="end">
        <Button
          kind="tertiary"
          onClick={handleCancel}
          size="small"
        >
          Cancel
        </Button>
        <Button
          kind="primary"
          onClick={handleSave}
          disabled={!canSave}
          size="small"
        >
          Save
        </Button>
      </Flex>
    </Box>
  );
};

// Helper function to get color based on status text
const getStatusColor = (status) => {
  if (!status) return "#c4c4c4";

  const statusLower = status.toLowerCase();

  // Monday.com default status colors
  if (statusLower.includes("done") || statusLower.includes("complete")) {
    return "#00c875"; // Green
  }
  if (statusLower.includes("working") || statusLower.includes("in progress")) {
    return "#fdab3d"; // Orange
  }
  if (statusLower.includes("stuck") || statusLower.includes("blocked")) {
    return "#e2445c"; // Red
  }
  if (statusLower.includes("waiting") || statusLower.includes("pending")) {
    return "#579bfc"; // Blue
  }

  // Default gray for unknown statuses
  return "#c4c4c4";
};

const App = () => {
  const [year, setYear] = useState(new Date().getFullYear());
  const [showSidePanel, setShowSidePanel] = useState(true);
  const [wheelSize, setWheelSize] = useState(500);
  const [zoomLevel, setZoomLevel] = useState(100); // Zoom percentage (50-150)
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 }); // Pan offset in pixels
  const yearWheelRef = useRef(null);

  // Tooltip state
  const [tooltipItem, setTooltipItem] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState(null);
  const [clusterItems, setClusterItems] = useState(null);
  const [clusterPosition, setClusterPosition] = useState(null);

  // Display settings
  const [showWeekRing, setShowWeekRing] = useState(true);
  const [showRingNames, setShowRingNames] = useState(true);
  const [showLabels, setShowLabels] = useState(true); // Always true - labels shown in center on hover
  const [weekRingDisplayMode, setWeekRingDisplayMode] =
    useState("week-numbers");

  // Color theme settings (loaded from monday.storage)
  const [colorTheme, setColorTheme] = useState("monday");
  const [colorMode, setColorMode] = useState("group");
  const [settingsLoaded, setSettingsLoaded] = useState(false);

  // Saved ring configuration (loaded from monday.storage)
  const [savedRingConfig, setSavedRingConfig] = useState(null);

  // Track if we just loaded config (to prevent immediate re-save)
  const configJustLoadedRef = useRef(false);
  const lastSavedConfigRef = useRef(null);

  // Track if initial wheel structure has been set (prevents re-initialization)
  const initCompleteRef = useRef(false);

  // Zoom state
  const [zoomedMonth, setZoomedMonth] = useState(null);
  const [zoomedQuarter, setZoomedQuarter] = useState(null);

  // Side panel active tab (to allow external control)
  const [sidePanelTab, setSidePanelTab] = useState(0);

  // Pan handlers
  const handlePan = useCallback((direction) => {
    const panStep = 150; // Pan 150px at a time for better navigation when zoomed
    setPanOffset(prev => {
      switch(direction) {
        case 'up': return { x: prev.x, y: prev.y + panStep };
        case 'down': return { x: prev.x, y: prev.y - panStep };
        case 'left': return { x: prev.x + panStep, y: prev.y };
        case 'right': return { x: prev.x - panStep, y: prev.y };
        default: return prev;
      }
    });
  }, []);

  // Reset pan when zoom level changes
  useEffect(() => {
    if (zoomLevel === 100) {
      setPanOffset({ x: 0, y: 0 });
    }
  }, [zoomLevel]);

  // Wheel structure (rings, activity groups, labels)
  const [wheelStructure, setWheelStructure] = useState({
    rings: [],
    activityGroups: [],
    labels: [],
    items: [],
  });

  // Track items with pending saves (to prevent backend data from overwriting optimistic updates)
  const pendingSavesRef = useRef(new Set());

  const {
    context,
    boardData,
    columns,
    groups,
    users,
    loading,
    loadingProgress,
    error,
    isViewerUser,
    wheelItems,
    openItem,
    updateItemDates,
    updateItemGroup,
    updateItemName,
    updateItemUsers,
    createItem,
    createGroup,
    updateGroup,
    deleteGroup,
    settings,
    setSettings,
  } = useMondayBoard();

  // Monday.com system theme (light/dark/black/night/hacker) - must be after useMondayBoard
  const mondayTheme = context?.theme || "light";
  
  // Canvas background color - dynamically detected from CSS variable
  const [canvasBackgroundColor, setCanvasBackgroundColor] = useState("#ffffff");

  // Monetization - check subscription and enforce limits
  const {
    subscription,
    loading: monetizationLoading,
    isPro,
    isTrial,
    isFree,
    hasExceededLimit,
    daysLeft,
    showUpgradePrompt,
    hasFeature,
    getUpgradeMessage,
  } = useMonetization(1); // Currently viewing 1 board

  // Handle item update from wheel (drag/resize)
  const handleItemUpdate = useCallback(
    async (updatedItem) => {
      if (updatedItem && updatedItem.id) {
        // Get the dates from the updated item
        let startDate = updatedItem.startDate || updatedItem.date;
        let endDate = updatedItem.endDate;
        const newRingId = updatedItem.ringId;

        // Validate dates: ensure end date is not before start date
        if (endDate && startDate && endDate < startDate) {
          console.warn(
            "âš ï¸ End date before start date detected, setting endDate to null"
          );
          endDate = null; // Convert to single-day item
        }

        // Check if ring/group changed
        const originalItem = wheelStructure.items.find(
          (i) => i.id === updatedItem.id
        );
        const ringChanged = originalItem && originalItem.ringId !== newRingId;

        // Update wheelStructure immediately
        setWheelStructure((prev) => ({
          ...prev,
          items: prev.items.map((item) => {
            if (item.id === updatedItem.id) {
              // If ring changed, also update activity group
              const newActivityId = ringChanged
                ? newRingId.replace("ring-", "activity-")
                : item.activityId;

              return {
                ...item,
                startDate,
                endDate,
                ringId: newRingId,
                activityId: newActivityId,
              };
            }
            return item;
          }),
        }));

        // Mark this item as having a pending save
        pendingSavesRef.current.add(updatedItem.id);

        // Save to Monday.com
        try {
          await updateItemDates(updatedItem.id, startDate, endDate);

          if (ringChanged) {
            const newGroupId = newRingId.replace("ring-", "");
            await updateItemGroup(updatedItem.id, newGroupId);
          }
        } finally {
          // Remove from pending saves after save completes (success or failure)
          pendingSavesRef.current.delete(updatedItem.id);
        }
      }
    },
    [year, updateItemDates, updateItemGroup, wheelStructure.items]
  );

  // Notify Monday that user has value
  useEffect(() => {
    monday.execute("valueCreatedForUser");
  }, []);
  
  // Apply Monday.com theme to body and detect background color + font for canvas
  useEffect(() => {
    // Remove any existing theme classes
    document.body.classList.remove("light-app-theme", "dark-app-theme", "black-app-theme", "night-app-theme", "hacker-app-theme", "hacker_theme-app-theme");
    // Add current theme class
    document.body.classList.add(`${mondayTheme}-app-theme`);
    
    // Wait a tick for CSS to apply, then read the computed styles
    requestAnimationFrame(() => {
      // Detect background color
      const bgColor = getComputedStyle(document.body).getPropertyValue('--primary-background-color').trim();
      if (bgColor) {
        setCanvasBackgroundColor(bgColor);
      }
      
      // For hacker theme, Monday.com uses a monospace font but doesn't expose it via CSS variable
      // We manually set it to match their aesthetic
      if (mondayTheme === 'hacker_theme') {
        document.body.style.fontFamily = '"Hack", "Fira Code", "Source Code Pro", Consolas, Monaco, monospace';
      } else {
        // Use the default Vibe font for other themes
        const fontFamily = getComputedStyle(document.body).getPropertyValue('--font-family').trim();
        if (fontFamily) {
          document.body.style.fontFamily = fontFamily;
        } else {
          document.body.style.fontFamily = ''; // Reset to CSS default
        }
      }
    });
  }, [mondayTheme, context?.theme]);

  // Load user settings from monday.storage on mount
  useEffect(() => {
    const loadSettings = async () => {
      // In development mode (localhost without Monday.com iframe), skip storage load
      if (isDevelopment && !context) {
        console.log('ðŸ“ Development mode: Skipping settings load, using defaults');
        setSettingsLoaded(true);
        return;
      }
      
      // In production, wait for context to be available before loading settings
      if (!context) {
        return; // Context not yet loaded, effect will re-run when it's available
      }
      
      // CRITICAL: Wait for boardId before loading ring config
      // This prevents loading from 'ringConfig_default' and then overwriting
      // the correct board-specific config
      const boardId = context?.boardId || context?.boardIds?.[0];

      if (!boardId) {
        return; // Don't set settingsLoaded yet - wait for boardId
      }

      try {
        // Load color theme
        const themeResult = await monday.storage.instance.getItem("colorTheme");
        if (themeResult.data?.value) {
          setColorTheme(themeResult.data.value);
        }

        // Load color mode
        const modeResult = await monday.storage.instance.getItem("colorMode");
        if (modeResult.data?.value) {
          setColorMode(modeResult.data.value);
        }

        // Load week ring display mode
        const weekModeResult = await monday.storage.instance.getItem(
          "weekRingDisplayMode"
        );
        if (weekModeResult.data?.value) {
          setWeekRingDisplayMode(weekModeResult.data.value);
        }

        // Load ring configuration from monday.storage.instance
        // Key is scoped by boardId to allow different configs per board
        const ringConfigKey = `ringConfig_${boardId}`;

        try {
          const ringConfigResult = await monday.storage.instance.getItem(
            ringConfigKey
          );

          // Monday.com storage returns: { data: { value: "string", version: "string" } }
          // or { data: { value: null } } if not found
          if (ringConfigResult?.data?.value) {
            const savedConfig = JSON.parse(ringConfigResult.data.value);
            configJustLoadedRef.current = true;
            // Store the comparable version (without lastUpdated) to prevent false change detection
            const comparableConfig = {
              version: savedConfig.version,
              rings: savedConfig.rings,
              activityGroups: savedConfig.activityGroups,
            };
            lastSavedConfigRef.current = JSON.stringify(comparableConfig);
            setSavedRingConfig(savedConfig);
          }
        } catch (storageError) {
          // Silently handle storage errors
        }
      } catch (error) {
        console.error("âŒ Could not load settings from monday.storage:", error);
      } finally {
        setSettingsLoaded(true);
      }
    };

    loadSettings();
  }, [context]); // Re-run when context changes

  // Calculate wheel size based on container
  useEffect(() => {
    const updateSize = () => {
      const container = document.querySelector(".wheel-container");
      if (container) {
        const rect = container.getBoundingClientRect();
        const size = Math.min(rect.width - 40, rect.height - 40, 700);
        setWheelSize(Math.max(size, 300));
      }
    };

    updateSize();
    window.addEventListener("resize", updateSize);
    return () => window.removeEventListener("resize", updateSize);
  }, [showSidePanel]);

  // Initialize wheel structure from Monday groups - only after settings are loaded
  useEffect(() => {
    // IMPORTANT: Wait for settings to be loaded before building wheel structure
    // This ensures savedRingConfig is available when we initialize
    if (!settingsLoaded) {
      return;
    }

    // CRITICAL: Only initialize ONCE - use ref to prevent re-initialization
    // This prevents the init from overwriting user changes when groups state updates
    if (initCompleteRef.current) {
      return;
    }

    if (groups.length > 0) {

      const theme = COLOR_THEMES[colorTheme];
      const themeColors = theme?.colors || [
        "#579bfc",
        "#9cd326",
        "#ff642e",
        "#ff5ac4",
        "#fdab3d",
        "#00c875",
        "#7e3b8a",
        "#0086c0",
      ];

      // Create inner rings from Monday groups, merging with saved configuration
      const rings = groups.map((group, index) => {
        // Check if saved config exists for this group
        const savedRing = savedRingConfig?.rings?.find(
          (r) => r.id === `ring-${group.id}` || r.originalGroupId === group.id
        );

        if (savedRing) {
          // Use saved configuration (user has customized this ring)
          return {
            id: `ring-${group.id}`,
            name: savedRing.name || group.title,
            type: savedRing.type || "inner",
            visible: savedRing.visible !== undefined ? savedRing.visible : true,
            orientation: savedRing.orientation || "horizontal",
            ring_order: savedRing.ring_order ?? index,
            color: savedRing.color || themeColors[index % themeColors.length],
            originalGroupId: group.id,
            originalGroupTitle: group.title,
            originalGroupColor: group.color, // Preserve Monday.com group color
          };
        } else {
          // New group (not in saved config) - use defaults
          return {
            id: `ring-${group.id}`,
            name: group.title,
            type: "inner",
            visible: true,
            orientation: "horizontal",
            ring_order: index,
            color: themeColors[index % themeColors.length],
            originalGroupId: group.id,
            originalGroupTitle: group.title,
            originalGroupColor: group.color, // Preserve Monday.com group color
          };
        }
      });

      // Add any custom rings from saved config (user-created rings not tied to Monday groups)
      const customRings =
        savedRingConfig?.rings?.filter((r) => r.isCustomRing) || [];
      rings.push(...customRings);

      // Sort by ring_order
      rings.sort((a, b) => (a.ring_order ?? 0) - (b.ring_order ?? 0));

      // Create activity groups from Monday groups, merging with saved configuration
      const activityGroups = groups.map((group, index) => {
        const savedGroup = savedRingConfig?.activityGroups?.find(
          (g) => g.id === `activity-${group.id}`
        );

        return {
          id: `activity-${group.id}`,
          name: savedGroup?.name || group.title,
          color: savedGroup?.color || themeColors[index % themeColors.length],
          visible:
            savedGroup?.visible !== undefined ? savedGroup.visible : true,
          originalGroupColor: group.color, // Preserve Monday.com group color
        };
      });

      // Mark init as complete BEFORE setting state to prevent race conditions
      initCompleteRef.current = true;

      setWheelStructure((prev) => ({
        ...prev,
        rings,
        activityGroups,
      }));
    }
  }, [groups.length, colorTheme, savedRingConfig, settingsLoaded]); // Wait for settings before init

  // Save ring configuration to board (debounced)
  useEffect(() => {
    // Skip if structure is empty or not yet initialized
    if (!wheelStructure.rings || wheelStructure.rings.length === 0) {
      return;
    }

    // Skip save if we just loaded the config (prevents infinite loop)
    if (configJustLoadedRef.current) {
      configJustLoadedRef.current = false;
      return;
    }

    // Build the config to compare
    const configToSave = {
      version: 1,
      rings: wheelStructure.rings.map((ring, index) => ({
        id: ring.id,
        type: ring.type,
        visible: ring.visible,
        name: ring.name,
        color: ring.color,
        ring_order: ring.ring_order ?? index, // Ensure ring_order is always set
        orientation: ring.orientation,
        isCustomRing: ring.isCustomRing || false,
        originalGroupId: ring.originalGroupId,
        originalGroupTitle: ring.originalGroupTitle,
      })),
      activityGroups:
        wheelStructure.activityGroups?.map((group) => ({
          id: group.id,
          visible: group.visible,
          name: group.name,
          color: group.color,
        })) || [],
    };

    const configString = JSON.stringify(configToSave);

    // Skip if config hasn't actually changed
    if (configString === lastSavedConfigRef.current) {
      return;
    }

    // Debounce saves to avoid excessive writes
    const saveTimeout = setTimeout(async () => {
      try {
        // Add timestamp to the config for save
        const config = {
          ...configToSave,
          lastUpdated: new Date().toISOString(),
        };

        const boardId = context?.boardId || context?.boardIds?.[0];
        const ringConfigKey = boardId
          ? `ringConfig_${boardId}`
          : "ringConfig_default";

        const configJson = JSON.stringify(config);

        const saveResult = await monday.storage.instance.setItem(
          ringConfigKey,
          configJson
        );

        if (saveResult.data?.success) {
          // Update last saved config ref
          lastSavedConfigRef.current = configString;
        }
      } catch (error) {
        console.error("âŒ Failed to save ring configuration:", error);
      }
    }, 1000); // 1s debounce to avoid rapid saves

    return () => clearTimeout(saveTimeout);
  }, [wheelStructure.rings, wheelStructure.activityGroups, context]);

  // Update colors when theme or colorMode changes
  useEffect(() => {
    if (wheelStructure.rings.length > 0) {
      const theme = COLOR_THEMES[colorTheme];
      if (!theme) return;

      const themeColors = theme.colors;

      setWheelStructure((prev) => ({
        ...prev,
        // ColorMode determines ring colors:
        // - 'theme': use theme palette colors
        // - 'group': use original Monday.com group colors
        rings: prev.rings.map((ring, index) => ({
          ...ring,
          color: colorMode === "group" && ring.originalGroupColor
            ? ring.originalGroupColor
            : themeColors[index % themeColors.length],
        })),
        activityGroups: prev.activityGroups.map((ag, index) => ({
          ...ag,
          color: colorMode === "group" && ag.originalGroupColor
            ? ag.originalGroupColor
            : themeColors[index % themeColors.length],
        })),
        items: prev.items.map((item, index) => {
          // ColorMode determines item colors:
          // - 'theme': use theme palette cycling through items
          // - 'group': preserve original Monday.com group color
          if (colorMode === "theme") {
            return {
              ...item,
              color: themeColors[index % themeColors.length],
            };
          }
          // In group mode, preserve the original Monday.com group color
          // Fall back to ring color if groupColor is not available
          if (item.groupColor) {
            return {
              ...item,
              color: item.groupColor,
            };
          }
          // Last resort: find the ring and use its color
          const ring = prev.rings.find((r) => r.id === item.ringId);
          if (ring?.originalGroupColor) {
            return {
              ...item,
              color: ring.originalGroupColor,
            };
          }
          return item;
        }),
      }));
    }
  }, [colorTheme, colorMode, groups]);

  // Update wheel structure items when wheelItems change
  useEffect(() => {
    if (wheelItems.length > 0 && wheelStructure.rings.length > 0) {
      // Extract unique status values to create labels
      const uniqueStatuses = [
        ...new Set(wheelItems.map((item) => item.status).filter(Boolean)),
      ];

      // Create label objects from unique statuses
      const labels = uniqueStatuses.map((status, index) => ({
        id: `label-${status.toLowerCase().replace(/\s+/g, "-")}`,
        name: status,
        visible: true,
        color: getStatusColor(status), // Color based on status type
      }));

      const transformedItems = wheelItems.map((item) => {
        const group = groups.find((g) => g.title === item.group);

        // Only set endDate if it's different from startDate (has actual duration)
        const hasRealDuration = item.endDate && item.endDate !== item.date;

        // Find label ID for this item's status
        const labelId = item.status
          ? `label-${item.status.toLowerCase().replace(/\s+/g, "-")}`
          : null;

        return {
          id: item.id,
          name: item.name,
          startDate: item.date,
          endDate: hasRealDuration ? item.endDate : null, // null = single-day dot
          ringId: group ? `ring-${group.id}` : wheelStructure.rings[0]?.id,
          activityId: group
            ? `activity-${group.id}`
            : wheelStructure.activityGroups[0]?.id,
          labelId,
          color: item.groupColor || (group ? group.color : null), // Use group color
          groupColor: item.groupColor || (group ? group.color : null), // Preserve original Monday.com group color
          assignedUserIds: item.assignedUserIds || [],
          assignedUsers: item.assignedUsers || [],
        };
      });

      // Only update if items have actually changed (not just a refetch of same data)
      // This preserves optimistic updates from drag operations
      setWheelStructure((prev) => {
        // If we already have items and the count is the same, merge instead of replace
        // This keeps optimistically updated positions while allowing backend updates
        if (
          prev.items.length > 0 &&
          prev.items.length === transformedItems.length
        ) {
          const mergedItems = transformedItems.map((newItem) => {
            const existingItem = prev.items.find((i) => i.id === newItem.id);
            if (!existingItem) return newItem;

            // CRITICAL: If this item has a pending save, keep the existing (optimistic) version
            // Don't let stale backend data overwrite the pending update
            if (pendingSavesRef.current.has(newItem.id)) {
              return existingItem;
            }

            // Check if the new item has different data (from successful API update)
            const datesChanged =
              existingItem.startDate !== newItem.startDate ||
              existingItem.endDate !== newItem.endDate;

            const ringChanged = existingItem.ringId !== newItem.ringId;
            const nameChanged = existingItem.name !== newItem.name;

            // If data changed in wheelItems (backend updated), use new data
            // Otherwise keep existing item (preserves optimistic drag changes)
            if (datesChanged || ringChanged || nameChanged) {
              return newItem;
            }

            return existingItem;
          });
          return { ...prev, items: mergedItems, labels };
        }

        // First load or item count changed - use new items
        return { ...prev, items: transformedItems, labels };
      });
    }
  }, [wheelItems.length, wheelStructure.rings.length]); // Only depend on lengths

  // Handle item click - show tooltip or cluster selection
  const handleItemClick = useCallback((itemOrItems, event) => {
    // Robust detection: could be array, single item, or clusterData object
    let items;
    if (Array.isArray(itemOrItems)) {
      items = itemOrItems;
    } else if (itemOrItems?.isCluster && itemOrItems?.items) {
      // It's a clusterData object - extract the items array
      items = itemOrItems.items;
    } else {
      // Single item
      items = [itemOrItems];
    }

    if (items.length > 1) {
      // Multiple items - show cluster selection
      setClusterItems(items);
      setClusterPosition({ x: event?.clientX || 0, y: event?.clientY || 0 });
      setTooltipItem(null);
      setTooltipPosition(null);
    } else if (items.length === 1) {
      // Single item - show edit tooltip
      const rect = event?.target?.getBoundingClientRect?.() || {
        left: 0,
        top: 0,
      };
      setTooltipItem(items[0]);
      setTooltipPosition({
        x: event?.clientX || rect.left,
        y: event?.clientY || rect.top,
      });
      setClusterItems(null);
      setClusterPosition(null);
    }
  }, []);

  // Handle smart filter for clustered items - applies filter and switches to Filter tab
  const handleSmartFilter = useCallback(() => {
    if (!clusterItems || clusterItems.length === 0) return;

    // Find the date range of clustered items
    const dates = clusterItems.map(item => new Date(item.startDate));
    const minDate = new Date(Math.min(...dates));
    const maxDate = new Date(Math.max(...dates));
    
    const minMonth = minDate.getMonth();
    const maxMonth = maxDate.getMonth();
    const sameMonth = minMonth === maxMonth;

    if (sameMonth) {
      // All items in same month - filter to that month
      setZoomedMonth(minMonth);
      setZoomedQuarter(null);
    } else {
      // Items span multiple months - filter to quarter
      const quarter = Math.floor(minMonth / 3);
      setZoomedQuarter(quarter);
      setZoomedMonth(null);
    }

    // Switch to Filter tab (tab index 2)
    setSidePanelTab(2);

    // Close cluster tooltip
    setClusterItems(null);
    setClusterPosition(null);
  }, [clusterItems]);

  // Handle item update from tooltip (all fields)
  const handleTooltipUpdate = useCallback(
    async (updates) => {
      const originalItem = wheelStructure.items.find(
        (i) => i.id === updates.id
      );
      if (!originalItem) return;

      // Check what changed
      const nameChanged = updates.name !== originalItem.name;
      const datesChanged =
        updates.startDate !== originalItem.startDate ||
        updates.endDate !== originalItem.endDate;
      const groupChanged = updates.ringId !== originalItem.ringId;
      const usersChanged = updates.userIds && 
        JSON.stringify(updates.userIds.sort()) !== JSON.stringify((originalItem.assignedUserIds || []).sort());

      // Update wheelStructure immediately
      setWheelStructure((prev) => ({
        ...prev,
        items: prev.items.map((item) =>
          item.id === updates.id ? { ...item, ...updates } : item
        ),
      }));

      // Update Monday.com in background
      if (nameChanged) {
        await updateItemName(updates.id, updates.name);
      }

      if (datesChanged) {
        await updateItemDates(updates.id, updates.startDate, updates.endDate);
      }

      if (groupChanged) {
        const newGroupId = updates.ringId.replace("ring-", "");
        await updateItemGroup(updates.id, newGroupId);
      }

      if (usersChanged) {
        await updateItemUsers(updates.id, updates.userIds);
      }
    },
    [wheelStructure.items, updateItemName, updateItemDates, updateItemGroup, updateItemUsers]
  );

  // Handle wheel structure changes from side panel
  const handleWheelStructureChange = useCallback((newStructure) => {
    setWheelStructure(newStructure);
  }, []);

  // Handle theme changes
  const handleThemeChange = useCallback(
    ({ theme, colorMode: newColorMode }) => {
      setColorTheme(theme);
      setColorMode(newColorMode);
      // Persist to monday.storage (instance-level, per board view)
      monday.storage.instance.setItem("colorTheme", theme);
      monday.storage.instance.setItem("colorMode", newColorMode);
    },
    []
  );

  // Handle week ring display mode changes
  const handleWeekRingDisplayModeChange = useCallback((mode) => {
    setWeekRingDisplayMode(mode);
    // Persist to monday.storage (instance-level, per board view)
    monday.storage.instance.setItem("weekRingDisplayMode", mode);
  }, []);

  // Handle reset ring configuration
  const handleResetConfiguration = useCallback(async () => {
    try {
      const boardId = context?.boardId || context?.boardIds?.[0];
      const ringConfigKey = boardId
        ? `ringConfig_${boardId}`
        : "ringConfig_default";

      await monday.storage.instance.deleteItem(ringConfigKey);

      lastSavedConfigRef.current = null;
      setSavedRingConfig(null);

      // Reset init flag to allow re-initialization
      initCompleteRef.current = false;

      // Clear wheel structure to trigger reload
      setWheelStructure((prev) => ({
        ...prev,
        rings: [],
        activityGroups: [],
      }));

      monday.execute("notice", {
        message: "Ring configuration reset to defaults",
        type: "success",
        timeout: 3000,
      });
    } catch (error) {
      console.error("Failed to reset configuration:", error);
      monday.execute("notice", {
        message: "Failed to reset configuration",
        type: "error",
        timeout: 3000,
      });
    }
  }, [context]);

  // Calculate colors array based on theme and mode
  const wheelColors = useMemo(() => {
    const theme = COLOR_THEMES[colorTheme];
    if (!theme) return [];

    // Return colors in the format expected by YearWheelClass:
    // [monthRing1, monthRing2, weekRing, ...activityColors]
    return [
      ...theme.monthRing, // [0-1] month ring alternating colors
      theme.weekRing, // [2] week ring color
      ...theme.colors, // [3+] activity/item colors
    ];
  }, [colorTheme]);

  // Filter and process items for selected year
  // Items spanning multiple years are split at year boundaries
  // Use wheelStructure.items for immediate updates from drag/resize
  const filteredItems = useMemo(() => {
    const yearStart = new Date(year, 0, 1);
    const yearEnd = new Date(year, 11, 31);

    const itemsForYear = [];

    wheelStructure.items.forEach((item) => {
      const itemStart = new Date(item.startDate);
      const itemEnd = item.endDate ? new Date(item.endDate) : itemStart;

      // Check if item overlaps with this year
      const overlapsYear = itemStart <= yearEnd && itemEnd >= yearStart;

      if (overlapsYear) {
        // Clamp dates to year boundaries
        const clampedStart = itemStart < yearStart ? yearStart : itemStart;
        const clampedEnd = itemEnd > yearEnd ? yearEnd : itemEnd;

        // Format dates as YYYY-MM-DD
        const formatDate = (d) => d.toISOString().split("T")[0];

        // Check if item continues beyond year boundaries
        const continuesFromPrevYear = itemStart < yearStart;
        const continuesToNextYear = itemEnd > yearEnd;

        itemsForYear.push({
          ...item,
          date: formatDate(clampedStart),
          startDate: formatDate(clampedStart),
          endDate: formatDate(clampedEnd),
          // Add metadata for visual indicators
          _continuesFromPrevYear: continuesFromPrevYear,
          _continuesToNextYear: continuesToNextYear,
          _originalStartDate: item.startDate,
          _originalEndDate: item.endDate || item.startDate,
        });
      }
    });

    // Apply colors based on colorMode
    if (colorMode === "theme") {
      const theme = COLOR_THEMES[colorTheme];
      return itemsForYear.map((item, index) => ({
        ...item,
        color: theme.colors[index % theme.colors.length],
      }));
    }

    // In group mode, preserve original group colors from wheelStructure.items
    return itemsForYear;
  }, [wheelStructure.items, year, colorMode, colorTheme]);

  // Loading state
  if (loading) {
    return (
      <div className="App loading-state">
        <Flex direction="column" align="center" gap="medium">
          <WheelLoader size="md" />
          <span className="loading-text">
            {loadingProgress || "Loading board data..."}
          </span>
        </Flex>
      </div>
    );
  }

  // Viewer access error state (special handling)
  if (error === "viewer_access" || isViewerUser) {
    return (
      <div className="App error-state">
        <Flex direction="column" align="center" gap="medium" style={{ padding: "32px", maxWidth: "600px", margin: "0 auto" }}>
          <AttentionBox
            title="Access Restricted"
            text="Year Wheel is not available for viewer accounts. Viewers don't have API access required to display board data."
            type="danger"
          />
          <Box style={{ textAlign: "center" }}>
            <Text type="text1" weight="bold" style={{ marginBottom: "8px", display: "block" }}>
              What can you do?
            </Text>
            <Text type="text2" color="secondary" style={{ marginBottom: "16px", display: "block" }}>
              Contact your board admin to upgrade your permission level to:
            </Text>
            <Flex direction="column" gap="xs" align="start" style={{ display: "inline-flex" }}>
              <Text type="text2">â€¢ <strong>Member</strong> - Full board access</Text>
              <Text type="text2">â€¢ <strong>Admin</strong> - Administrative access</Text>
              <Text type="text2">â€¢ <strong>Guest</strong> - Limited board access</Text>
            </Flex>
          </Box>
        </Flex>
      </div>
    );
  }

  // General error state
  if (error) {
    return (
      <div className="App error-state">
        <AttentionBox title="Error loading board" text={error} type="danger" />
      </div>
    );
  }

  return (
    <div className={`App ${showSidePanel ? "with-sidepanel" : ""}`}>
      {/* Upgrade Prompts */}
      {hasExceededLimit && (
        <div style={{ padding: "16px", backgroundColor: "#f5f6f8" }}>
          <UpgradePrompt
            message={getUpgradeMessage()}
            onUpgrade={showUpgradePrompt}
            type="danger"
          />
        </div>
      )}

      {isTrial && daysLeft <= 3 && (
        <div style={{ padding: "16px", backgroundColor: "#fff4e6" }}>
          <UpgradePrompt
            message="Your trial is ending soon!"
            onUpgrade={showUpgradePrompt}
            type="warning"
            showTrialInfo
            daysLeft={daysLeft}
          />
        </div>
      )}

      {/* Main Content */}
      <div className="main-content">
        {/* Header */}
        <div className="header">
          <Flex align="center" gap="small">
            <IconButton
              icon={MenuIcon}
              kind="tertiary"
              size="small"
              onClick={() => setShowSidePanel(!showSidePanel)}
              active={showSidePanel}
              ariaLabel="Toggle side panel"
            />
            <span className="board-name">{boardData?.name || "YearWheel"}</span>
          </Flex>

          {/* Year Navigation */}
          <Flex align="center" gap="small">
            <IconButton
              icon={NavigationChevronLeft}
              kind="tertiary"
              size="small"
              onClick={() => setYear(year - 1)}
              ariaLabel="Previous year"
            />
            <span className="year-display">
              {year}
            </span>
            <IconButton
              icon={NavigationChevronRight}
              kind="tertiary"
              size="small"
              onClick={() => setYear(year + 1)}
              ariaLabel="Next year"
            />
            <Button
              size="small"
              kind="tertiary"
              onClick={() => setYear(new Date().getFullYear())}
            >
              Today
            </Button>
          </Flex>

          {/* Zoom Controls */}
          <Flex align="center" gap="xs" className="zoom-controls">
            <IconButton
              icon={Remove}
              kind="tertiary"
              size="small"
              onClick={() => setZoomLevel(prev => Math.max(50, prev - 10))}
              disabled={zoomLevel <= 50}
              ariaLabel="Zoom out"
            />
            <input
              type="range"
              min="50"
              max="150"
              value={zoomLevel}
              onChange={(e) => setZoomLevel(Number(e.target.value))}
              className="zoom-slider"
              aria-label="Zoom level"
            />
            <IconButton
              icon={Add}
              kind="tertiary"
              size="small"
              onClick={() => setZoomLevel(prev => Math.min(150, prev + 10))}
              disabled={zoomLevel >= 150}
              ariaLabel="Zoom in"
            />
            <span className="zoom-value">{zoomLevel}%</span>
            <IconButton
              icon={Fullscreen}
              kind="tertiary"
              size="small"
              onClick={() => setZoomLevel(100)}
              disabled={zoomLevel === 100}
              ariaLabel="Fit to screen"
              title="Fit to screen"
            />
          </Flex>

          <span className="item-count">
            {filteredItems.length} item{filteredItems.length !== 1 ? "s" : ""}{" "}
            in {year}
          </span>
        </div>

        {/* Wheel Container */}
        <div className="wheel-container" style={{ overflow: 'hidden', position: 'relative' }}>
          <div 
            className="wheel-zoom-wrapper"
            style={{ 
              transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel / 100})`,
              transformOrigin: 'center center',
              transition: 'transform 0.2s ease-out',
              width: zoomLevel > 100 ? `${zoomLevel}%` : '100%',
              height: zoomLevel > 100 ? `${zoomLevel}%` : '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
          {filteredItems.length > 0 || wheelStructure.items.length > 0 ? (
            <MondayYearWheel
              key={`wheel-${colorTheme}-${colorMode}`}
              ref={yearWheelRef}
              items={filteredItems}
              groups={groups}
              year={year}
              title={boardData?.name || "YearWheel"}
              ringMode="group"
              colors={wheelColors}
              showWeekRing={showWeekRing}
              weekRingDisplayMode={weekRingDisplayMode}
              showMonthRing={true}
              showRingNames={showRingNames}
              showLabels={showLabels}
              renderSize={2000}
              readonly={false}
              externalWheelStructure={wheelStructure}
              zoomedMonth={zoomedMonth}
              zoomedQuarter={zoomedQuarter}
              canvasBackgroundColor={canvasBackgroundColor}
              onItemClick={handleItemClick}
              onItemUpdate={handleItemUpdate}
            />
          ) : (
            <div className="empty-state">
              <AttentionBox
                title="No items to display"
                text={`No items with dates found in ${year}. Make sure your board has items with date columns.`}
                type="primary"
              />
            </div>
          )}
        </div>

          {/* Pan Controls - grouped in diamond pattern at top right, only show when zoomed in */}
          {zoomLevel > 100 && (
            <div className="pan-controls-group">
              <IconButton
                className="pan-control pan-up"
                icon={NavigationChevronUp}
                kind="secondary"
                size="small"
                onClick={() => handlePan('up')}
                ariaLabel="Pan up"
                title="Pan up"
              />
              <IconButton
                className="pan-control pan-left"
                icon={NavigationChevronLeft}
                kind="secondary"
                size="small"
                onClick={() => handlePan('left')}
                ariaLabel="Pan left"
                title="Pan left"
              />
              <IconButton
                className="pan-control pan-down"
                icon={NavigationChevronDown}
                kind="secondary"
                size="small"
                onClick={() => handlePan('down')}
                ariaLabel="Pan down"
                title="Pan down"
              />
              <IconButton
                className="pan-control pan-right"
                icon={NavigationChevronRight}
                kind="secondary"
                size="small"
                onClick={() => handlePan('right')}
                ariaLabel="Pan right"
                title="Pan right"
              />
            </div>
          )}
        </div>
      </div>

      {/* Side Panel */}
      {showSidePanel && (
        <div className="sidepanel-container">
          <WheelSidePanel
            wheelStructure={wheelStructure}
            onWheelStructureChange={handleWheelStructureChange}
            onResetConfiguration={handleResetConfiguration}
            showWeekRing={showWeekRing}
            onShowWeekRingChange={setShowWeekRing}
            weekRingDisplayMode={weekRingDisplayMode}
            onWeekRingDisplayModeChange={handleWeekRingDisplayModeChange}
            showRingNames={showRingNames}
            onShowRingNamesChange={setShowRingNames}
            colorTheme={colorTheme}
            colorMode={colorMode}
            onThemeChange={handleThemeChange}
            year={year}
            zoomedMonth={zoomedMonth}
            onZoomToMonth={setZoomedMonth}
            zoomedQuarter={zoomedQuarter}
            onZoomToQuarter={setZoomedQuarter}
            activeTab={sidePanelTab}
            onActiveTabChange={setSidePanelTab}
            mondayItems={filteredItems}
            allItems={wheelStructure.items}
            users={users}
            userFilter={settings?.userFilter}
            onUserFilterChange={(userId) => setSettings(prev => ({ ...prev, userFilter: userId }))}
            onItemClick={handleItemClick}
            yearWheelRef={yearWheelRef}
            isPro={isPro}
            isTrial={isTrial}
            hasFeature={hasFeature}
            onUpgrade={showUpgradePrompt}
            createGroup={createGroup}
            updateGroup={updateGroup}
            columns={columns}
            groups={groups}
            settings={settings}
            onSettingsChange={setSettings}
            deleteGroup={deleteGroup}
            createItem={createItem}
          />
        </div>
      )}

      {/* Cluster Tooltip */}
      {clusterItems && clusterPosition && (
        <ClusterTooltip
          items={clusterItems}
          position={clusterPosition}
          onClose={() => {
            setClusterItems(null);
            setClusterPosition(null);
          }}
          onFilter={handleSmartFilter}
        />
      )}

      {/* Edit Tooltip */}
      {tooltipItem && tooltipPosition && !clusterItems && (
        <ItemTooltip
          item={tooltipItem}
          position={tooltipPosition}
          groups={groups}
          users={users}
          onClose={() => {
            setTooltipItem(null);
            setTooltipPosition(null);
          }}
          onUpdate={handleTooltipUpdate}
        />
      )}
    </div>
  );
};

export default App;
